% Copyright 2018-2021 by Romano Giannetti
% Copyright 2015-2021 by Stefan Lindner
% Copyright 2013-2021 by Stefan Erhardt
% Copyright 2007-2021 by Massimo Redaelli
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Public License.
%
% See the files gpl-3.0_license.txt and lppl-1-3c_license.txt for more details.

\def\pgf@circ@handleSI#1{
    \noexpandarg
    \def\pgf@temp{}
    \StrBetween{#1}{<}{>}[\pgf@circ@handleSI@unit]
    \StrLen{\pgf@circ@handleSI@unit}[\pgf@circ@handleSI@unit@len]

    \ifnum\pgf@circ@handleSI@unit@len=0
    \pgf@circ@siunitx@resfalse
    \else
    \IfEndWith{#1}{>}{
        \pgf@circ@siunitx@restrue
        \noexpandarg
        \StrBefore{#1}{<}[\pgf@circ@handleSI@val]
        %\typeout{si |#1|}
        }{
        \pgf@circ@siunitx@resfalse
        %\typeout{no si |#1|}
    }
\fi
}

\def\pgf@circ@ifkeyempty#1{
    \pgfextra{
        \ctikzset{#1/.get=\pgf@circ@temp}
        \edef\pgf@temp{}
    }
    \ifx\pgf@circ@temp\pgf@temp
    }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%    Math routines

\def\pgf@circ@stripdecimals#1.#2\pgf@nil{#1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% useful commands

\ifpgfutil@format@is@latex
    %% flipping text
    \def\ctikzflipx#1{\scalebox{-1}[1]{#1}}
    \def\ctikzflipy#1{\scalebox{1}[-1]{#1}}
    \def\ctikzflipxy#1{\scalebox{-1}[-1]{#1}}
    % text mode overbar
    % Thanks to @egreg https://tex.stackexchange.com/a/24133/38080
    \def\ctikztextnot#1{$\overline{\hbox{#1}}\m@th$}
\else\ifpgfutil@format@is@plain
    % text mode overbar
    % Thanks to @egreg https://tex.stackexchange.com/a/24133/38080
    \def\ctikztextnot#1{$\overline{\hbox{#1}}$}
\else\ifpgfutil@format@is@context
    % text mode overbar
    % Thanks to @egreg https://tex.stackexchange.com/a/24133/38080
    \def\ctikztextnot#1{$\overline{\hbox{#1}}$}
\fi\fi\fi

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% switch to use fpu in reciprocal scale transformations
%%
%% this code has been contributed by SchrÃ¶dinger's cat
%% https://tex.stackexchange.com/a/529159/38080
%%
%% Use the official key to use the fpu if installed, see
%% https://github.com/pgf-tikz/pgf/issues/861
%%
%% Thanks to "muzimuzhi Z" https://tex.stackexchange.com/a/547085/38080
%%
\pgfkeysifdefined{/pgf/fpu/install only/.@cmd}{%
    \pgfqkeys{/pgf}{use fpu reciprocal/.code={\pgfkeys{/pgf/fpu/install only={reciprocal}}}}%
    }{%
    \pgfqkeys{/pgf}{use fpu reciprocal/.code={%
    \def\pgfmathreciprocal@##1{%
        \begingroup
        \pgfkeys{/pgf/fpu=true,/pgf/fpu/output format=fixed}%
        \pgfmathparse{1/##1}%
        \pgfmath@smuggleone\pgfmathresult
        \endgroup
    }}}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% subcircuits (experimental)
%%
%% introduced by Romano Giannetti around April 2021
%%
%%
\newbox\ctikz@scratchbox
\long\def\ctikzsubcircuitdef#1#2#3{%
    \expandafter\gdef\csname #1@Anchor\endcsname{}
    \expandafter\gdef\csname #1@setanchors\endcsname{
        \setbox\ctikz@scratchbox=\hbox{%
        \begin{circuitikz}
        \draw (0,0) \csname#1\endcsname{T-#1}{};
        \foreach [count=\i] \anchor in {#2}
        % reference anchor is -center
        \draw (0,{2-\i/2}) let \p1 = ($(T-#1-subckt@reference)-(T-#1-\anchor)$) in
            node[right]{\anchor: \x1,\y1 \expandafter\xdef\csname #1@Anchor\anchor\endcsname{++(\x1,\y1)}};
        \end{circuitikz}
        }
    }
    \expandafter\gdef\csname#1\endcsname##1##2{\csname#1aux\endcsname{##1}{\csname #1@Anchor##2\endcsname}}
    \expandafter\gdef\csname#1aux\endcsname##1##2{%
    % move to the anchor
    ##2
    % reference anchor should be -reference
    coordinate (##1-subckt@reference)
    #3
    }
}
\long\def\ctikzsubcircuitactivate#1{\csname #1@setanchors\endcsname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% list handling
%%
%% The list implementation here has a few limitations. Those are:
%%  1. not long, so no \par in the lists (but many used functions in pgfutil
%%     aren't long as well)
%%  2. list elements can't contain a Q with category code 3 (but the used
%%     function \pgfutil@trimspaces doesn't support them as well, and this
%%     should be a very rare token anyway)
%%  3. list elements can't contain the token \pgf@circ@set@list as that is used
%%     as the end marker
%%
%% Functions provided here are:
%%  \pgf@circ@set@list<macro>{<csv-list>}
%%    Parses the <csv-list> and stores the result inside <macro> (local
%%    assignment)
%%  \pgf@circ@if@num@in@list<macro>{<value>}{<true>}{<false>}
%%    Checks whether <value> (numeric value, evaluated once with \numexpr) is
%%    found inside the list stored in <macro>. There are two special cases: If
%%    <macro> is undefined <false> is executed. If the list contains only one
%%    element and that is `all' <true> is executed.

% set the catcode of our marker
\chardef\pgf@circ@temp=\the\catcode`\Q
\catcode`\Q=3

% lists will have the structure
% <marker><element 1><marker>...<element n><marker>
% As marker we use a Q with category 3. Under the assumption that no list
% element does ever contain that token we can set the elements without braces,
% allowing us to use \pgfutil@in@ to search for elements (see above). The other
% token that isn't allowed to show up in the list is \pgf@circ@set@list, that we
% use as another marker during parsing.
% The other big restriction in this implementation is that lists can't contain a
% \par (but \pgfutil@in@ doesn't support that anyway so there is not much
% sense in supporting it here)
\pgfutil@protected\def\pgf@circ@set@list#1#2%
  {%
    % clear the error flag
    \let\pgf@circ@error@marker\pgf@circ@undefined
    % set the list
    \edef#1%
      {Q\pgf@circ@set@list@sanitize#2,\pgf@circ@set@list,\pgf@circ@set@list}%
    % there was an error, throw the error message, recovery was already done by
    % ignoring the offending elements.
    \ifx\pgf@circ@error@marker\relax
      \begingroup
        \newlinechar`\^^J
        \pgfutil@packageerror{circuitikz}
          {%
            Unallowed marker found in list^^J%
            \pgfutil@unexpanded{#2}.^^J%
            Offending elements were ignored.%
          }
          {Lists can't contain a Q with category code 3}%
      \endgroup
    \fi
  }
% just a utility for the <marker> test
\def\pgf@circ@set@list@gobbletomarker#1Q{}
% quick way to check whether list parsing is done by gobbling up to a marker, in
% this case the marker is \pgf@circ@set@list
\def\pgf@circ@set@list@sanitize@checkend#1\pgf@circ@set@list{}
% will only be called after the last element is handled, will gobble the
% remainder of the current sanitizing step
\def\pgf@circ@set@list@sanitize@end\pgf@circ@set@list#1\pgf@circ@set@list{}
% grabs the next list element, checks whether we're done, and if not sanitizes
% it (meaning stripping spaces from either end and placing the <marker>).
\def\pgf@circ@set@list@sanitize#1,%
  {%
    \pgf@circ@set@list@sanitize@checkend
      #1\pgf@circ@set@list@sanitize@end\pgf@circ@set@list
    \pgf@circ@set@list@sanitize@a{#1}%
  }
% testing whether a list element contains the used <marker> expandably, if it
% does set the flag, else continue sanitizing.
\def\pgf@circ@set@list@sanitize@a#1%
  {%
    \expandafter\pgfutil@ifempty\expandafter
      % if this is empty no marker was found
      {\pgf@circ@set@list@gobbletomarker#1Q}
      {%
        % \pgfutil@trimspaces uses \romannumeral to trim up to one set of spaces
        % and needs exactly two steps of expansion
        \expandafter\expandafter\expandafter
        \pgf@circ@set@list@sanitize@b
        \expandafter\expandafter\expandafter
          {\pgfutil@trimspaces{#1}}%
      }
      {%
        % panic, there was a marker found in a list element. We'll recover by
        % ignoring the current element after setting a flag. When we do
        % \csname ...\endcsname on an undefined macro name TeX will let that
        % macro to relax and we exploit this to expandable set a flag and
        % gobbling the result.
        \expandafter\pgfutil@gobble\csname pgf@circ@error@marker\endcsname
        % get the next element
        \pgf@circ@set@list@sanitize
      }%
  }
% we'll protect any element from further expanding using \unexpanded and place
% the marker after the element, and ignore empty/blank elements
\def\pgf@circ@set@list@sanitize@b#1%
  {%
    \pgfutil@ifempty{#1}%
      {}% ignore empty/blank elements
      {\pgfutil@unexpanded{#1}Q}%
    % get next element
    \pgf@circ@set@list@sanitize
  }

% flag for special value
\def\pgf@circ@all@flag{QallQ}
\pgfutil@protected\def\pgf@circ@if@num@in@list#1#2%
  {%
    % test whether the list macro is defined, if it isn't result is false
    \pgfutil@ifx\pgf@circ@undefined#1%
      {\pgfutil@secondoftwo}
      {%
        % test whether the list macro is just the special value 'all', if so
        % true, else search (and start that by evaluating a numexpr)
        \pgfutil@ifx\pgf@circ@all@flag#1%
          {\pgfutil@firstoftwo}
          {%
            \expandafter\pgf@circ@if@num@in@list@a\expandafter
              {\the\numexpr#2}%
              #1%
          }%
      }%
  }
% next step is expanding the list macro
\pgfutil@protected\def\pgf@circ@if@num@in@list@a#1#2%
  {\expandafter\pgf@circ@if@num@in@list@b\expandafter{#2}{#1}}
% now use \pgfutil@in@ to check whether there is the searched list element
\pgfutil@protected\def\pgf@circ@if@num@in@list@b#1#2%
  {%
    \begingroup
      % put the <marker> around the number to make sure only full matches are
      % found. \pgfutil@in@ will set \ifpgfutil@in@ to true if it finds a match
      \pgfutil@in@{Q#2Q}{#1}%
      \expandafter
    \endgroup
    \ifpgfutil@in@
      \expandafter\pgfutil@firstoftwo
    \else
      \expandafter\pgfutil@secondoftwo
    \fi
  }

% reset the catcode of Q
\catcode`\Q=\pgf@circ@temp

\endinput
